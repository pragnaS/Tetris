#include "../inc/tm4c123gh6pm.h"
#include <stdint.h>
#include "tetris_grid.h"

#define GRID_WIDTH 12		//board width in blocks
#define GRID_HEIGHT 16		//board height in blocks


//...................................................IMAGES.......................................................................//
const unsigned short red[] = {
 0x20FD, 0x20FD, 0x20FD, 0x20FD, 0x20FD, 0x20FD, 0x20FD, 0x20FD, 0x20FD, 0x20FD, 0x20FD, 0x20FD, 0x20FD, 0x20FD, 0x20FD, 0x20FD,
 0x20FD, 0x20FD, 0x20FD, 0x20FD, 0x20FD, 0x20FD, 0x20FD, 0x20FD, 0x20FD, 0x20FD, 0x20FD, 0x20FD, 0x20FD, 0x20FD, 0x20FD, 0x20FD,
 0x20FD, 0x20FD, 0x20FD, 0x20FD, 0x20FD, 0x20FD, 0x20FD, 0x20FD, 0x20FD, 0x20FD, 0x20FD, 0x20FD, 0x20FD, 0x20FD, 0x20FD, 0x20FD,
 0x20FD, 0x20FD, 0x20FD, 0x20FD, 0x20FD, 0x20FD, 0x20FD, 0x20FD, 0x20FD, 0x20FD, 0x20FD, 0x20FD, 0x20FD, 0x20FD, 0x20FD, 0x20FD,
 0x20FD, 0x20FD, 0x20FD, 0x20FD, 0x20FD, 0x20FD, 0x20FD, 0x20FD, 0x20FD, 0x20FD, 0x20FD, 0x20FD, 0x20FD, 0x20FD, 0x20FD, 0x20FD,
 0x20FD, 0x20FD, 0x20FD, 0x20FD, 0x20FD, 0x20FD, 0x20FD, 0x20FD, 0x20FD, 0x20FD, 0x20FD, 0x20FD, 0x20FD, 0x20FD, 0x20FD, 0x20FD,
 0x20FD, 0x20FD, 0x20FD, 0x20FD

};

const unsigned short yellow[] = {
 0x079F, 0x079F, 0x079F, 0x079F, 0x079F, 0x079F, 0x079F, 0x079F, 0x079F, 0x079F, 0x079F, 0x079F, 0x079F, 0x079F, 0x079F, 0x079F,
 0x079F, 0x079F, 0x079F, 0x079F, 0x079F, 0x079F, 0x079F, 0x079F, 0x079F, 0x079F, 0x079F, 0x079F, 0x079F, 0x079F, 0x079F, 0x079F,
 0x079F, 0x079F, 0x079F, 0x079F, 0x079F, 0x079F, 0x079F, 0x079F, 0x079F, 0x079F, 0x079F, 0x079F, 0x079F, 0x079F, 0x079F, 0x079F,
 0x079F, 0x079F, 0x079F, 0x079F, 0x079F, 0x079F, 0x079F, 0x079F, 0x079F, 0x079F, 0x079F, 0x079F, 0x079F, 0x079F, 0x079F, 0x079F,
 0x079F, 0x079F, 0x079F, 0x079F, 0x079F, 0x079F, 0x079F, 0x079F, 0x079F, 0x079F, 0x079F, 0x079F, 0x079F, 0x079F, 0x079F, 0x079F,
 0x079F, 0x079F, 0x079F, 0x079F, 0x079F, 0x079F, 0x079F, 0x079F, 0x079F, 0x079F, 0x079F, 0x079F, 0x079F, 0x079F, 0x079F, 0x079F,
 0x079F, 0x079F, 0x079F, 0x079F,

};

const unsigned short green[] = {
 0x4D84, 0x4D84, 0x4D84, 0x4D84, 0x4D84, 0x4D84, 0x4D84, 0x4D84, 0x4D84, 0x4D84, 0x4D84, 0x4D84, 0x4D84, 0x4D84, 0x4D84, 0x4D84,
 0x4D84, 0x4D84, 0x4D84, 0x4D84, 0x4D84, 0x4D84, 0x4D84, 0x4D84, 0x4D84, 0x4D84, 0x4D84, 0x4D84, 0x4D84, 0x4D84, 0x4D84, 0x4D84,
 0x4D84, 0x4D84, 0x4D84, 0x4D84, 0x4D84, 0x4D84, 0x4D84, 0x4D84, 0x4D84, 0x4D84, 0x4D84, 0x4D84, 0x4D84, 0x4D84, 0x4D84, 0x4D84,
 0x4D84, 0x4D84, 0x4D84, 0x4D84, 0x4D84, 0x4D84, 0x4D84, 0x4D84, 0x4D84, 0x4D84, 0x4D84, 0x4D84, 0x4D84, 0x4D84, 0x4D84, 0x4D84,
 0x4D84, 0x4D84, 0x4D84, 0x4D84, 0x4D84, 0x4D84, 0x4D84, 0x4D84, 0x4D84, 0x4D84, 0x4D84, 0x4D84, 0x4D84, 0x4D84, 0x4D84, 0x4D84,
 0x4D84, 0x4D84, 0x4D84, 0x4D84, 0x4D84, 0x4D84, 0x4D84, 0x4D84, 0x4D84, 0x4D84, 0x4D84, 0x4D84, 0x4D84, 0x4D84, 0x4D84, 0x4D84,
 0x4D84, 0x4D84, 0x4D84, 0x4D84,

};

const unsigned short blue[] = {
 0xCA47, 0xCA47, 0xCA47, 0xCA47, 0xCA47, 0xCA47, 0xCA47, 0xCA47, 0xCA47, 0xCA47, 0xCA47, 0xCA47, 0xCA47, 0xCA47, 0xCA47, 0xCA47,
 0xCA47, 0xCA47, 0xCA47, 0xCA47, 0xCA47, 0xCA47, 0xCA47, 0xCA47, 0xCA47, 0xCA47, 0xCA47, 0xCA47, 0xCA47, 0xCA47, 0xCA47, 0xCA47,
 0xCA47, 0xCA47, 0xCA47, 0xCA47, 0xCA47, 0xCA47, 0xCA47, 0xCA47, 0xCA47, 0xCA47, 0xCA47, 0xCA47, 0xCA47, 0xCA47, 0xCA47, 0xCA47,
 0xCA47, 0xCA47, 0xCA47, 0xCA47, 0xCA47, 0xCA47, 0xCA47, 0xCA47, 0xCA47, 0xCA47, 0xCA47, 0xCA47, 0xCA47, 0xCA47, 0xCA47, 0xCA47,
 0xCA47, 0xCA47, 0xCA47, 0xCA47, 0xCA47, 0xCA47, 0xCA47, 0xCA47, 0xCA47, 0xCA47, 0xCA47, 0xCA47, 0xCA47, 0xCA47, 0xCA47, 0xCA47,
 0xCA47, 0xCA47, 0xCA47, 0xCA47, 0xCA47, 0xCA47, 0xCA47, 0xCA47, 0xCA47, 0xCA47, 0xCA47, 0xCA47, 0xCA47, 0xCA47, 0xCA47, 0xCA47,
 0xCA47, 0xCA47, 0xCA47, 0xCA47,

};

const unsigned short orange[] = {
 0x23FF, 0x23FF, 0x23FF, 0x23FF, 0x23FF, 0x23FF, 0x23FF, 0x23FF, 0x23FF, 0x23FF, 0x23FF, 0x23FF, 0x23FF, 0x23FF, 0x23FF, 0x23FF,
 0x23FF, 0x23FF, 0x23FF, 0x23FF, 0x23FF, 0x23FF, 0x23FF, 0x23FF, 0x23FF, 0x23FF, 0x23FF, 0x23FF, 0x23FF, 0x23FF, 0x23FF, 0x23FF,
 0x23FF, 0x23FF, 0x23FF, 0x23FF, 0x23FF, 0x23FF, 0x23FF, 0x23FF, 0x23FF, 0x23FF, 0x23FF, 0x23FF, 0x23FF, 0x23FF, 0x23FF, 0x23FF,
 0x23FF, 0x23FF, 0x23FF, 0x23FF, 0x23FF, 0x23FF, 0x23FF, 0x23FF, 0x23FF, 0x23FF, 0x23FF, 0x23FF, 0x23FF, 0x23FF, 0x23FF, 0x23FF,
 0x23FF, 0x23FF, 0x23FF, 0x23FF, 0x23FF, 0x23FF, 0x23FF, 0x23FF, 0x23FF, 0x23FF, 0x23FF, 0x23FF, 0x23FF, 0x23FF, 0x23FF, 0x23FF,
 0x23FF, 0x23FF, 0x23FF, 0x23FF, 0x23FF, 0x23FF, 0x23FF, 0x23FF, 0x23FF, 0x23FF, 0x23FF, 0x23FF, 0x23FF, 0x23FF, 0x23FF, 0x23FF,
 0x23FF, 0x23FF, 0x23FF, 0x23FF,

};

const unsigned short black[] = {
 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
 0x0000, 0x0000, 0x0000, 0x0000,

};
//.....................................................IMAGES.....................................................................//

//Definition of tetris pieces

char pieces[5][4][3][3]= //5 pieces, 4 rotations, 3 by 3 shape
{
	//Square
	{
		{
		{0,0,0},
		{0,1,1},
		{0,1,1}
		},
		{
		{0,0,0},
		{0,1,1},
		{0,1,1}
		},
		{
		{0,0,0},
		{0,1,1},
		{0,1,1}
		},
		{
		{0,0,0},
		{0,1,1},
		{0,1,1}
		}
	},
	//L-piece
	{
		{
			{0,0,0},
			{0,2,0},
			{0,2,2}
		},
		{
			{0,0,0},
			{0,2,0},
			{2,2,0}
		},
		{
			{0,0,0},
			{0,2,2},
			{0,2,0}
		},
		{
			{0,0,0},
			{2,2,0},
			{0,2,0}
		}
	},
	//Z-piece
	{
		{
			{0,0,0},
			{0,3,3},
			{3,3,0}
		},
		{
			{0,0,0},
			{3,3,0},
			{0,3,3}
		},
		{
			{3,0,0},
			{3,3,0},
			{0,3,0}
		},
		{
			{0,0,3},
			{0,3,3},
			{0,3,0}
		}
	},
	//T-piece
	{
		{
			{0,0,0},
			{0,4,0},
			{4,4,4}
		},
		{
			{4,4,4},
			{0,4,0},
			{0,0,0}
		},
		{
			{0,0,4},
			{0,4,4},
			{0,0,4}
		},
		{
			{4,0,0},
			{4,4,0},
			{4,0,0}
		}
	},
	//I-piece
	{
		{
			{0,5,0},
			{0,5,0},
			{0,5,0}
		},
		{
			{0,0,0},
			{5,5,5},
			{0,0,0}
		},
		{
			{0,5,0},
			{0,5,0},
			{0,5,0}
		},
		{
			{0,0,0},
			{5,5,5},
			{0,0,0}
		}
	}
};

int grid[GRID_WIDTH][GRID_HEIGHT];

//This function initialises the tetris grid
void Grid_Init(void)
{
	for(int i=0; i<GRID_WIDTH; i++)
	{
		for(int j=0; j<GRID_HEIGHT; j++)
		{
			grid[i][j]=0;
		}
	}
}

//This function stores the piece in the grid by filling the appropriate blocks with FILLED
void Store_Piece(int x, int y, int pieceType, int rotation)
{
	int pieceI=0, pieceJ=0;
	for(volatile int i=x, pieceI=0; i<x+3; i++, pieceI++)
	{
		for(volatile int j=y, pieceJ=0; j<y+3; j++, pieceJ++)
		{
			grid[i][j]=pieces[pieceType][rotation][pieceI][pieceJ];
		}
	}
}

//This function checks if the game is over when a piece reaches the topmost row
//Output: 1 if game is over, 0 if game is not over
int isGameOver(void)
{
	for(int i=0; i<GRID_WIDTH; i++)
	{
		volatile int check = grid[i][1];
		if(check!=0)
		{
			return 1;
		}
	}
	return 0;
}

//This function erases a line that is completely filled and moves all the upper rows one row down
//Inputs: Vertical position of the line to delete
void DeleteLine(int y)
{
	for(int i=y; i>0; i--)
	{
		for(int j=0; j<GRID_WIDTH; j++)
		{
			grid[j][i]=grid[j][i-1];
		}
	}
}

//This function deletes all the lines that should be removed
void DeletePossibleLines()
{
	for(int j=0; j<GRID_HEIGHT; j++)
	{
		int i=0;
		while(i<GRID_WIDTH)
		{
			if(grid[i][j]==0)
				break;
			i++;
		}
		if(i==GRID_WIDTH)
			DeleteLine(j);
	}
}

//This function checks if a block in the grid is free or not 
//Inputs: x is the horizontal cooridinate, y is the vertical coordinate
//Output: 1 if it is not a free block, 0 if it is a free block
int isFreeBlock(int x, int y)
{
	if(grid[x][y]==0)
		return 0;
	else
		return 1;
}


//This function checks for possible collisions
//Output: 1 if move is possible, 0 if move is not possible
int isMovePossible(int x, int y, int pieceType, int rotation)
{
	int pieceI=0, pieceJ=0;
	for(int i=x; i<x+3; i++)
	{
		for(int j=y; j<y+3; j++)
		{
			//checking if piece is outside the board
			if(i<0 || i>GRID_WIDTH || j>GRID_HEIGHT)
			{
				if(getBlockType(pieceType, rotation, pieceI, pieceJ)!=0)
					return 0; 	//move is not possible
			}
			
			//checking if piece has collisioned with a filled block
			if(j>0)
			{
				if(getBlockType(pieceType, rotation, pieceI, pieceJ)!=0 && isFreeBlock(i,j)==1)
					return 0;  //move not possible
			}
			pieceJ++;
		}
		pieceI++;
	}
	return 1; //move is possible
}

//This function returns the coordinate (in pixels) of the block
//Input: coordinate of the block in the grid
int GetPosinPixels(int pos)
{
	return(10*pos);
}

//This function returns the type of block in the piece
//Output: 0 if no block, 1: red block, 2: blue block, 3: green block, 4:yellow block, 5:orange block
//Input: pieceType, rotation, x, y
int getBlockType(int pieceType, int rotation, int x, int y)
{
	return pieces[pieceType][rotation][x][y];
}

void DrawPiece(int type, int orientation, int x, int y)
{
	int pieceI=0, pieceJ=0;
	
	for(int i=x, pieceI=0; i<x+3; i++, pieceI++)
	{
		for(int j=y, pieceJ=0; j<y+3; j++, pieceJ++)
		{
			if(pieces[type][orientation][pieceI][pieceJ]!=0)
			{
				if(type==0)
					ST7735_DrawBitmap(10*i, 10*j, red, 10,10);
				if(type==1)
					ST7735_DrawBitmap(10*i, 10*j, blue, 10,10);
				if(type==2)
					ST7735_DrawBitmap(10*i, 10*j, green, 10,10);
				if(type==3)
					ST7735_DrawBitmap(10*i, 10*j, yellow, 10,10);
				if(type==4)
					ST7735_DrawBitmap(10*i, 10*j, orange, 10,10);
			}
		}
	}
}

//This function renders the grid to the screen
void DrawGrid(void)
{
	for(int i=0; i<GRID_WIDTH; i++)
	{
		for(int j=0; j<GRID_HEIGHT; j++)
		{
			if(grid[i][j]==1)
				ST7735_DrawBitmap(10*i, 10*j, red, 10,10);
			if(grid[i][j]==2)
				ST7735_DrawBitmap(10*i, 10*j, blue, 10,10);
			if(grid[i][j]==3)
				ST7735_DrawBitmap(10*i, 10*j, green, 10,10);
			if(grid[i][j]==4)
				ST7735_DrawBitmap(10*i, 10*j, yellow, 10,10);
			if(grid[i][j]==5)
				ST7735_DrawBitmap(10*i, 10*j, orange, 10,10);
		
		}
	}
}

//This function restores the initial position of the new random piece




