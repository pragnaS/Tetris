#include "../inc/tm4c123gh6pm.h"
#include <stdint.h>
#include "tetris_grid.h"
#include "ST7735.h"

#define GRID_WIDTH 10		//board width in blocks
#define GRID_HEIGHT 16		//board height in blocks


//...................................................IMAGES.......................................................................//
const unsigned short red[] = {
 0x000A, 0x000C, 0x000E, 0x0011, 0x0013, 0x0035, 0x0057, 0x009A, 0x00BC, 0x00FF, 0x000A, 0x000C, 0x000E, 0x0011, 0x0013, 0x0035,
 0x0057, 0x009A, 0x00BC, 0x00FF, 0x000A, 0x000C, 0x000E, 0x0011, 0x0013, 0x0035, 0x0057, 0x009A, 0x00BC, 0x00FF, 0x000A, 0x000C,
 0x000E, 0x0011, 0x0013, 0x0035, 0x0057, 0x009A, 0x00BC, 0x00FF, 0x000A, 0x000C, 0x000E, 0x0011, 0x0013, 0x0035, 0x0057, 0x009A,
 0x00BC, 0x00FF, 0x000A, 0x000C, 0x000E, 0x0011, 0x0013, 0x0035, 0x0057, 0x009A, 0x00BC, 0x00FF, 0x000A, 0x000C, 0x000E, 0x0011,
 0x0013, 0x0035, 0x0057, 0x009A, 0x00BC, 0x00FF, 0x000A, 0x000C, 0x000E, 0x0011, 0x0013, 0x0035, 0x0057, 0x009A, 0x00BC, 0x00FF,
 0x000A, 0x000C, 0x000E, 0x0011, 0x0013, 0x0035, 0x0057, 0x009A, 0x00BC, 0x00FF, 0x000A, 0x000C, 0x000E, 0x0011, 0x0013, 0x0035,
 0x0057, 0x009A, 0x00BC, 0x00FF,

};



const unsigned short yellow[] = {
 0x175F, 0x175F, 0x175F, 0x175F, 0x175F, 0x175F, 0x175F, 0x0F5F, 0x0F5F, 0x0F5F, 0x275F, 0x275F, 0x275F, 0x275F, 0x275F, 0x275F,
 0x275E, 0x275F, 0x275F, 0x275E, 0x3F5E, 0x3F5E, 0x3F7E, 0x3F5E, 0x3F5F, 0x3F7E, 0x3F5F, 0x3F5F, 0x3F5F, 0x3F5E, 0x575E, 0x575E,
 0x575E, 0x575E, 0x575E, 0x575E, 0x575E, 0x575E, 0x575E, 0x575E, 0x5F5E, 0x5F5E, 0x5F5E, 0x5F5E, 0x675E, 0x5F5E, 0x5F5E, 0x5F5E,
 0x5F5E, 0x5F5E, 0x677E, 0x677E, 0x677E, 0x675E, 0x677E, 0x677E, 0x677E, 0x677E, 0x677E, 0x677E, 0x6F5E, 0x6F5E, 0x6F5E, 0x6F5E,
 0x6F5E, 0x6F5E, 0x6F5E, 0x6F5E, 0x6F5E, 0x6F5E, 0x6F7E, 0x6F7E, 0x6F5E, 0x6F5E, 0x6F7E, 0x6F7E, 0x6F7E, 0x6F5E, 0x6F7E, 0x6F7E,
 0x775E, 0x775E, 0x775E, 0x775E, 0x775E, 0x775E, 0x775E, 0x775E, 0x775E, 0x775E, 0x777E, 0x777E, 0x777E, 0x777E, 0x777E, 0x777E,
 0x777E, 0x777E, 0x777E, 0x777E,

};



const unsigned short green[] = {
 0x15AD, 0x156D, 0x152C, 0x14EC, 0x14CC, 0x14CC, 0x148B, 0x0C4A, 0x0BE9, 0x0BE9, 0x1E0E, 0x1DCE, 0x158E, 0x156D, 0x154D, 0x154D,
 0x150C, 0x0C8B, 0x0C4A, 0x0C09, 0x1E4F, 0x1E2F, 0x1DEF, 0x1DEF, 0x15CF, 0x15AE, 0x154D, 0x14EC, 0x148B, 0x144A, 0x2690, 0x266F,
 0x2650, 0x2650, 0x1E50, 0x15EF, 0x1DAE, 0x1D6D, 0x150C, 0x148B, 0x2ED1, 0x2EB1, 0x2EB1, 0x2691, 0x2691, 0x2650, 0x2610, 0x1DAE,
 0x154D, 0x14AB, 0x36F1, 0x36F2, 0x36F2, 0x2ED2, 0x36D3, 0x2E92, 0x2650, 0x1E0F, 0x15AE, 0x150C, 0x3F32, 0x3F12, 0x3712, 0x3F13,
 0x4714, 0x2ED2, 0x2690, 0x1E4F, 0x160E, 0x154D, 0x4753, 0x4733, 0x4F34, 0x4F34, 0x3713, 0x2EF2, 0x26D1, 0x1E90, 0x162E, 0x158D,
 0x4754, 0x5F55, 0x5F55, 0x4733, 0x3713, 0x2F12, 0x26F1, 0x1ED0, 0x166F, 0x160E, 0x6775, 0x6F76, 0x5755, 0x4733, 0x3F33, 0x3732,
 0x2712, 0x1EF1, 0x1EAF, 0x164F,

};


const unsigned short blue[] = {
 0x60E1, 0x7142, 0x79C2, 0x8A43, 0x92A4, 0x92E5, 0x92E5, 0x8AA5, 0x8264, 0x7A03, 0x6902, 0x79A2, 0x8A23, 0x9AC4, 0xA325, 0xA365,
 0xA366, 0x9B26, 0x92C5, 0x8244, 0x7142, 0x81C2, 0x9283, 0xA304, 0xABA5, 0xB3E6, 0xB3C6, 0xAB86, 0x9B06, 0x8A84, 0x7141, 0x8A02,
 0x9AA3, 0xAB64, 0xBBE6, 0xBC27, 0xBC26, 0xB3C6, 0xA345, 0x92C5, 0x7961, 0x8A02, 0xA2C3, 0xB384, 0xBC05, 0xC446, 0xC446, 0xB406,
 0xAB65, 0x92C4, 0x7961, 0x8A02, 0xA2C3, 0xB384, 0xC405, 0xCC66, 0xC466, 0xBC06, 0xAB85, 0x92C4, 0x7962, 0x9202, 0xA2C3, 0xB364,
 0xC405, 0xCC66, 0xC446, 0xBC05, 0xAB65, 0x92C4, 0x7962, 0x89E2, 0xA282, 0xB323, 0xBBC4, 0xC425, 0xC405, 0xB3C5, 0xAB44, 0x92C3,
 0x7141, 0x89C2, 0x9A62, 0xAB03, 0xB363, 0xBBC4, 0xBBC5, 0xAB84, 0xA324, 0x92A3, 0x6922, 0x81A1, 0x9222, 0x9AA3, 0xAB03, 0xAB44,
 0xAB64, 0xA324, 0x9AE4, 0x8A63,

};



const unsigned short orange[] = {
 0x1CFE, 0x1D5F, 0x159F, 0x159F, 0x0D7E, 0x0D7E, 0x0D9E, 0x057E, 0x053E, 0x04BC, 0x1D3F, 0x1D9F, 0x1DDF, 0x1DDF, 0x15BE, 0x15DE,
 0x0DDE, 0x0DBF, 0x059E, 0x051E, 0x257F, 0x25BF, 0x25FF, 0x1DFF, 0x1DFF, 0x15FE, 0x15FF, 0x0DFF, 0x05BF, 0x057F, 0x1D9F, 0x1DDF,
 0x1E1F, 0x1E1F, 0x1E1F, 0x161F, 0x161F, 0x0DFF, 0x05DF, 0x059F, 0x1D7F, 0x1DBF, 0x1DFF, 0x1DFF, 0x15FF, 0x15FF, 0x0DFF, 0x0DFF,
 0x05BF, 0x057F, 0x151F, 0x155F, 0x159F, 0x159F, 0x15BF, 0x0DBF, 0x0DBF, 0x059F, 0x057F, 0x053F, 0x0C9E, 0x0CFE, 0x0D1E, 0x0D3E,
 0x0D3E, 0x0D5E, 0x053E, 0x053F, 0x04FE, 0x04BE, 0x0C1D, 0x0C5D, 0x0C9E, 0x0CBE, 0x04BE, 0x04DE, 0x04BE, 0x049E, 0x047D, 0x043C,
 0x0B7B, 0x03BC, 0x03FD, 0x041D, 0x043D, 0x043D, 0x043D, 0x03FC, 0x03DC, 0x039B, 0x02F9, 0x035B, 0x037B, 0x039C, 0x03BC, 0x03BC,
 0x03BC, 0x039B, 0x035A, 0x0319,

};




//.....................................................IMAGES.....................................................................//

//Definition of tetris pieces

char pieces[5][4][3][3]= //5 pieces, 4 rotations, 3 by 3 shape
{
	//Square
	{
		{
		{0,0,0},
		{1,1,0},
		{1,1,0}
		},
		{
		{0,0,0},
		{1,1,0},
		{1,1,0}
		},
		{
		{0,0,0},
		{1,1,0},
		{1,1,0}
		},
		{
		{0,0,0},
		{1,1,0},
		{1,1,0}
		}
	},
	//L-piece
	{
		{
			{2,0,0},
			{2,0,0},
			{2,2,0}
		},
		{
			{0,0,0},
			{0,0,2},
			{2,2,2}
		},
		{
			{2,2,0},
			{0,2,0},
			{0,2,0}
		},
		{
			{0,2,0},
			{0,2,0},
			{2,2,0}
		}
	},
	//Z-piece
	{
		{
			{0,0,0},
			{0,3,3},
			{3,3,0}
		},
		{
			{3,0,0},
			{3,3,0},
			{0,3,0}
		},
		{
			{0,3,0},
			{3,3,0},
			{3,0,0}
		},
		{
			{0,0,0},
			{3,3,0},
			{0,3,3}
		}
	},
	//T-piece
	{
		{
			{0,0,0},
			{0,4,0},
			{4,4,4}
		},
		{
			{0,4,0},
			{4,4,0},
			{0,4,0}
		},
		{
			{0,0,0},
			{4,4,4},
			{0,4,0}
		},
		{
			{4,0,0},
			{4,4,0},
			{4,0,0}
		}
	},
	//I-piece
	{
		{
			{5,0,0},
			{5,0,0},
			{5,0,0}
		},
		{
			{0,0,0},
			{0,0,0},
			{5,5,5}
		},
		{
			{5,0,0},
			{5,0,0},
			{5,0,0}
		},
		{
			{0,0,0},
			{0,0,0},
			{5,5,5}
		}
	}
};


int grid[GRID_WIDTH][GRID_HEIGHT];

//This function initialises the tetris grid
void Grid_Init(void)
{
	for(int i=0; i<GRID_WIDTH; i++)
	{
		for(int j=0; j<GRID_HEIGHT; j++)
		{
			grid[j][i]=0;
		}
	}
}


//This function stores the piece in the grid by filling the appropriate blocks
void Store_Piece(int x, int y, int pieceType, int rotation)
{
	int pieceI=0, pieceJ=0;
	for(volatile int i=x, pieceI=0; i<x+3; i++, pieceI++)
	{
		for(volatile int j=y, pieceJ=0; j<y+3; j++, pieceJ++)
		{
			if(grid[i][j]!=0)
				continue;
			else
				grid[i][j]=pieces[pieceType][rotation][pieceJ][pieceI];
		}
	}
}

//This function checks if the game is over when a piece reaches the topmost row
//Output: 1 if game is over, 0 if game is not over
int isGameOver(void)
{
	for(int i=0; i<GRID_WIDTH; i++)
	{
		volatile int check = grid[i][1];
		if(check!=0)
		{
			return 1;
		}
	}
	return 0;
}

//This function erases a line that is completely filled and moves all the upper rows one row down
//Inputs: Vertical position of the line to delete
void DeleteLine(int y)
{
	for(int i=y; i>0; i--)
	{
		for(int j=0; j<GRID_WIDTH; j++)
		{
			grid[i][j]=grid[i-1][j];
		}
	}
}

//This function deletes all the lines that should be removed
int DeletePossibleLines()
{
	int line=0;
	for(int i=0; i<GRID_HEIGHT; i++)
	{
		int j=0;
		
		while(j<GRID_WIDTH-1)
		{
			if(grid[i][j]==0)
				break;
			j++;
		}
		
		if(j==GRID_WIDTH-1)
		{
			DeleteLine(i);
			line++;
		}
	}
	return line;
}

//This function checks if a block in the grid is free or not 
//Inputs: x is the horizontal cooridinate, y is the vertical coordinate
//Output: 1 if it is not a free block, 0 if it is a free block
int isFreeBlock(int x, int y)
{
	if(grid[x][y]==0)
		return 0;
	else
		return 1;
}


//This function checks for possible collisions
//Output: 1 if move is possible, 0 if move is not possible
int isMovePossible(int x, int y, int pieceType, int rotation)
{
	int pieceI=0, pieceJ=0;
	for(int i=x, pieceI=0; i<x+3; i++, pieceI++)
	{
		for(int j=y, pieceJ=0; j<y+3; j++, pieceJ++)
		{
			//checking if piece is outside the board
			if(i<0 || i>GRID_WIDTH || j>GRID_HEIGHT)
			{
				if(getBlockType(pieceType, rotation, pieceJ, pieceI)!=0)
					return 0; 	//move is not possible
			}
			
			//checking if piece has collisioned with a filled block
			if(j>0)
			{
				if(getBlockType(pieceType, rotation, pieceJ, pieceI)!=0 && grid[i][j]!=0)
					return 0;  //move not possible
			}
		}
	}
	return 1; //move is possible
}

//This function returns the coordinate (in pixels) of the block
//Input: coordinate of the block in the grid
int GetPosinPixels(int pos)
{
	return(10*pos);
}

//This function returns the type of block in the piece
//Output: 0 if no block, 1: red block, 2: blue block, 3: green block, 4:yellow block, 5:orange block
//Input: pieceType, rotation, x, y
int getBlockType(int pieceType, int rotation, int x, int y)
{
	return pieces[pieceType][rotation][x][y];
}

void DrawPiece(int type, int orientation, int x, int y)
{
	int pieceI=0, pieceJ=0;
	
	for(int i=x, pieceI=0; i<x+3; i++, pieceI++)
	{
		for(int j=y, pieceJ=0; j<y+3; j++, pieceJ++)
		{
			if(pieces[type][orientation][pieceJ][pieceI]!=0)
			{
				if(type==0)
					ST7735_DrawBitmap(10*i, 10*j, red, 10,10);
				if(type==1)
					ST7735_DrawBitmap(10*i, 10*j, blue, 10,10);
				if(type==2)
					ST7735_DrawBitmap(10*i, 10*j, green, 10,10);
				if(type==3)
					ST7735_DrawBitmap(10*i, 10*j, yellow, 10,10);
				if(type==4)
					ST7735_DrawBitmap(10*i, 10*j, orange, 10,10);
			}
		}
	}
}

//This function renders the grid to the screen
void DrawGrid(void)
{
	for(int i=0; i<GRID_WIDTH; i++)
	{
		for(int j=0; j<GRID_HEIGHT+1; j++)
		{
			if(grid[i][j]==1)
				ST7735_DrawBitmap(10*i, 10*j, red, 10,10);
			if(grid[i][j]==2)
				ST7735_DrawBitmap(10*i, 10*j, blue, 10,10);
			if(grid[i][j]==3)
				ST7735_DrawBitmap(10*i, 10*j, green, 10,10);
			if(grid[i][j]==4)
				ST7735_DrawBitmap(10*i, 10*j, yellow, 10,10);
			if(grid[i][j]==5)
				ST7735_DrawBitmap(10*i, 10*j, orange, 10,10);
		
		}
	}
}

//This function restores the initial position of the new random piece




